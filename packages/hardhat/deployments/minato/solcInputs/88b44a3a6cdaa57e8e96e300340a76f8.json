{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/PlannH3r.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract PlannH3r {\n    IERC20 public immutable stakingToken; // MXNB\n    IERC20 public immutable rewardToken;  // ASTR (para recompensas, si aplica)\n\n    struct Goal {\n        address user;\n        string description;\n        string activityType;\n        uint256 stakeAmount;\n        uint256 startDate;\n        uint256 endDate;\n        bool isCompleted;\n        bool isClaimed;\n    }\n\n    string public constant contractTag = \"PlannH3r Contract!\";\n\n    uint256 public goalCount;\n    mapping(uint256 => Goal) public goals;\n    mapping(address => uint256[]) public userGoals;\n    mapping(address => uint256) public userPoints;\n    mapping(address => uint256) public userStakeBalance;\n\n    uint256 public communityPool;\n\n    event GoalCreated(uint256 goalId, address user, uint256 stakeAmount, uint256 startDate, uint256 endDate);\n    event GoalCompleted(uint256 goalId);\n    event StakeHandled(uint256 goalId, address user, bool success, uint256 pointsEarned);\n\n    constructor(address _mxnbToken, address _astrToken) {\n        stakingToken = IERC20(_mxnbToken);\n        rewardToken = IERC20(_astrToken);\n    }\n\n    function createGoal(\n        string calldata _description,\n        string calldata _activityType,\n        uint256 _startDate,\n        uint256 _durationDays,\n        uint256 _stakeAmount\n    ) external {\n        require(_stakeAmount > 0, \"Debes depositar un stake\");\n        require(_startDate >= block.timestamp, \"Fecha de inicio invalida\");\n        require(stakingToken.transferFrom(msg.sender, address(this), _stakeAmount), \"Transfer failed\");\n\n        goalCount++;\n        uint256 endDate = _startDate + (_durationDays * 1 days);\n\n        goals[goalCount] = Goal({\n            user: msg.sender,\n            description: _description,\n            activityType: _activityType,\n            stakeAmount: _stakeAmount,\n            startDate: _startDate,\n            endDate: endDate,\n            isCompleted: false,\n            isClaimed: false\n        });\n\n        userGoals[msg.sender].push(goalCount);\n        userStakeBalance[msg.sender] += _stakeAmount;\n\n        emit GoalCreated(goalCount, msg.sender, _stakeAmount, _startDate, endDate);\n    }\n\n    function completeGoal(uint256 _goalId, uint256 _points) external {\n        Goal storage goal = goals[_goalId];\n        require(msg.sender == goal.user, \"No puedes modificar esta meta\");\n        require(block.timestamp >= goal.startDate, \"Aun no empieza\");\n        require(block.timestamp <= goal.endDate, \"Meta expirada\");\n        require(!goal.isCompleted, \"Ya fue completada\");\n\n        goal.isCompleted = true;\n        userPoints[msg.sender] += _points;\n\n        emit GoalCompleted(_goalId);\n        emit StakeHandled(_goalId, msg.sender, true, _points);\n    }\n\n    function claimGoal(uint256 _goalId) external {\n        Goal storage goal = goals[_goalId];\n        require(msg.sender == goal.user, \"No es tu meta\");\n        require(block.timestamp > goal.endDate, \"Aun no termina\");\n        require(!goal.isClaimed, \"Ya reclamada\");\n\n        goal.isClaimed = true;\n\n        if (!goal.isCompleted) {\n            uint256 penalty = goal.stakeAmount / 2;\n            communityPool += penalty;\n            userStakeBalance[msg.sender] -= penalty;\n            emit StakeHandled(_goalId, msg.sender, false, 0);\n        }\n    }\n\n    function withdrawStake(uint256 amount) external {\n        require(userStakeBalance[msg.sender] >= amount, \"Saldo insuficiente\");\n        userStakeBalance[msg.sender] -= amount;\n        require(stakingToken.transfer(msg.sender, amount), \"Transfer failed\");\n    }\n\n    function getUserGoals(address _user) external view returns (uint256[] memory) {\n        return userGoals[_user];\n    }\n\n    function donateToPool(uint256 amount) external {\n        require(stakingToken.transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\n        communityPool += amount;\n    }\n\n    function getPoints(address _user) external view returns (uint256) {\n        return userPoints[_user];\n    }\n\n    // (Opcional) función para premiar con ASTR al completar metas, si deseas distribuir tokens\n    function claimReward(uint256 amount) external {\n        // Aquí podrías usar una lógica de validación con puntos\n        require(rewardToken.transfer(msg.sender, amount), \"Reward transfer failed\");\n    }\n}\n"
    },
    "contracts/SimpleStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\ninterface IERC20 {\n    function transfer(address recipient, uint256 amount) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n}\n\ncontract SimpleStaking {\n    IERC20 public stakingToken;\n    uint256 public rewardRate; // Porcentaje de recompensa en base 1000 (ej: 50 = 5%)\n    uint256 public lockTime;   // Tiempo mínimo de staking en segundos\n\n    string public constant contractTag = \"Simple Staking Contract!\";\n\n    struct Stake {\n        uint256 amount;\n        uint256 timestamp;\n    }\n\n    mapping(address => Stake) public stakes;\n\n    constructor(address _stakingToken, uint256 _rewardRate, uint256 _lockTime) {\n        stakingToken = IERC20(_stakingToken);\n        rewardRate = _rewardRate; // ej. 50 = 5%\n        lockTime = _lockTime;     // ej. 604800 = 7 días\n    }\n\n    function stake(uint256 amount) external {\n        require(amount > 0, \"Debes stakear un monto > 0\");\n        require(stakes[msg.sender].amount == 0, \"Ya tienes un stake activo\");\n\n        require(stakingToken.transferFrom(msg.sender, address(this), amount), \"Fallo la transferencia\");\n\n        stakes[msg.sender] = Stake({\n            amount: amount,\n            timestamp: block.timestamp\n        });\n    }\n\n    function withdraw() external {\n        Stake memory userStake = stakes[msg.sender];\n        require(userStake.amount > 0, \"No tienes stake activo\");\n\n        uint256 stakingDuration = block.timestamp - userStake.timestamp;\n        uint256 reward = 0;\n\n        if (stakingDuration >= lockTime) {\n            reward = (userStake.amount * rewardRate) / 1000;\n        }\n\n        delete stakes[msg.sender];\n\n        require(stakingToken.transfer(msg.sender, userStake.amount + reward), \"Fallo el retiro\");\n    }\n\n    function getStakeInfo(address user) external view returns (uint256 amount, uint256 timestamp) {\n        Stake memory s = stakes[user];\n        return (s.amount, s.timestamp);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}